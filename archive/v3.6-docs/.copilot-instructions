# HSC JIT v3 - Copilot System Instructions

## ðŸŽ¯ Core Philosophy: "The Psychic Engine"

We are building a production-grade Just-In-Time (JIT) Technical Support System with:

1. **Zero Latency** - Predict user intent while typing (sub-200ms)
2. **JIT Document Retrieval** - No pre-indexing; download and index manuals on-demand
3. **Event-Driven Architecture** - WebSocket streaming for real-time responses
4. **Production-Ready Infrastructure** - Redis Pub/Sub, multi-layer caching, auto-scaling

---

## ðŸ—ï¸ Architectural Principles

### 1. Data Source of Truth

- **All product data** comes from `backend/data/catalogs/` (90+ brand JSON files)
- **Never** hardcode URLs or product information
- **Always** validate against catalog schema

### 2. State Management

- **Ephemeral state** - Redis cache (L1: memory, L2: Redis)
- **Session data** - Redis with TTL
- **No persistent DB** - PostgreSQL only for optional analytics
- **Stateless pods** - All state shareable across instances

### 3. Service Architecture

- **SnifferService** - Fuzzy matching for predictive search (TheFuzz)
- **CatalogService** - Loads and indexes all product catalogs
- **ContentFetcher** - Async downloads & caches PDF/HTML manuals
- **EphemeralRAG** - JIT embeddings & semantic retrieval
- **GeminiService** - Streaming LLM responses

### 4. Frontend Principles

- **WebSocket-first** - Real-time bidirectional communication
- **Event-driven UI** - React to backend events (`prediction`, `status`, `answer_chunk`)
- **Virtual scrolling** - Handle 1000+ messages efficiently
- **Glassmorphism design** - Modern, clean aesthetic

---

## ðŸ› ï¸ Tech Stack

### Backend

- **Framework:** FastAPI + Uvicorn (async WebSocket support)
- **Cache:** Redis 6+ (Pub/Sub + multi-layer caching)
- **AI/ML:** Google Gemini API (LLM), SentenceTransformers (embeddings)
- **Search:** TheFuzz (fuzzy matching)
- **HTTP:** HTTPX (async client for PDF/HTML fetching)
- **Parsing:** PyMuPDF (PDF), BeautifulSoup4 (HTML)

### Frontend

- **Framework:** React 18 + TypeScript
- **Build:** Vite 5 (fast dev server, HMR)
- **Styling:** Tailwind CSS (utility-first)
- **State:** Zustand (lightweight store)
- **WebSocket:** Native WebSocket API

### Infrastructure

- **Container:** Docker + Docker Compose
- **Orchestration:** Kubernetes (production)
- **Monitoring:** Prometheus + Grafana
- **Logging:** Structured JSON logs
- **CI/CD:** GitHub Actions

---

## ðŸ“‹ Development Guidelines

### Code Style

```python
# Backend - Always use type hints
async def predict_product(
    self,
    query: str,
    limit: int = 5
) -> List[Dict[str, Any]]:
    """
    Predict products from partial query.

    Args:
        query: User input text
        limit: Maximum results to return

    Returns:
        List of product dictionaries with scores
    """
    pass
```

```typescript
// Frontend - Explicit types
interface PredictionEvent {
  type: "prediction";
  products: Product[];
  confidence: number;
}

const handlePrediction = (event: PredictionEvent): void => {
  // Handle prediction
};
```

### File Organization

```
backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ core/              # Infrastructure (cache, health, metrics, logging)
â”‚   â”œâ”€â”€ services/          # Business logic (sniffer, rag, llm, fetcher)
â”‚   â””â”€â”€ main.py            # FastAPI app + WebSocket endpoint

frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/        # React components
â”‚   â”œâ”€â”€ store/             # State management (WebSocket)
â”‚   â””â”€â”€ App.tsx            # Main app

docs/
â”œâ”€â”€ architecture/          # System design
â”œâ”€â”€ deployment/            # Production guides
â”œâ”€â”€ operations/            # Runbook, troubleshooting
â””â”€â”€ testing/               # Test reports
```

### WebSocket Message Format

```json
{
  "type": "prediction|query|status|answer_chunk|error",
  "data": {
    // Type-specific payload
  },
  "timestamp": "2026-01-11T12:00:00Z",
  "session_id": "uuid-v4"
}
```

### Error Handling

- **Always** catch exceptions at service boundaries
- **Always** log errors with context
- **Never** expose internal errors to frontend
- **Always** send user-friendly error messages

---

## ðŸš€ Performance Targets

| Metric                   | Target  | Current   |
| ------------------------ | ------- | --------- |
| Prediction latency (P95) | <200ms  | ~50-100ms |
| LLM answer (P95)         | <5s     | ~2-4s     |
| Cache hit rate           | >60%    | ~70-85%   |
| Memory per pod           | <1GB    | ~600MB    |
| CPU per pod              | <1 core | ~0.5 core |

---

## âœ… Before Committing

1. **Tests** - Run `pytest tests/ -v` (all must pass)
2. **Type checks** - No type errors in Python/TypeScript
3. **Linting** - Code follows style guidelines
4. **Documentation** - Update relevant docs in `docs/`
5. **No secrets** - No API keys or credentials in code

---

## ðŸ“š Key Documentation

- **Architecture:** `docs/architecture/ARCHITECTURE.md`
- **Development:** `docs/development/IMPLEMENTATION_SUMMARY.md`
- **Operations:** `docs/operations/RUNBOOK.md`
- **Testing:** `docs/testing/TESTING_GUIDE.md`

---

## ðŸ”§ Common Commands

```bash
# Start local development
./start.sh

# Run tests
pytest tests/ -v

# Check health
curl http://localhost:8000/health

# View metrics
curl http://localhost:8000/metrics

# Clean cache
redis-cli FLUSHDB
```

---

**Version:** 3.6 (Static-First Architecture)  
**Last Updated:** January 2026
