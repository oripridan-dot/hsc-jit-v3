# üîå v3.6 Frontend Integration Guide

## Overview

The v3.6 static build system generates JSON files that replace your current API endpoints. Here's how to integrate them into your React frontend.

---

## üéØ Integration Strategy

### Current (v3.5) - API-Based
```
User Types ‚Üí WebSocket ‚Üí Backend API ‚Üí Database ‚Üí Response
                ‚Üì
          Real-time predictions
```

### Target (v3.6) - Static-First
```
User Types ‚Üí Fuse.js (in-memory) ‚Üí Instant results
              ‚Üì
        Load once: /data/index.json
```

---

## üì¶ What's Already Built

The build system generates these files:

```
frontend/public/data/
‚îú‚îÄ‚îÄ index.json              # Master catalog (all products, searchable)
‚îú‚îÄ‚îÄ nord.json               # Per-brand detailed catalogs
‚îú‚îÄ‚îÄ roland.json
‚îú‚îÄ‚îÄ adam-audio.json
‚îî‚îÄ‚îÄ ... (38 brand files)
```

---

## üîÑ Step-by-Step Integration

### Phase 1: Add Static Data Loader (Week 2, Day 1)

**Create: `frontend/src/lib/catalogLoader.ts`**

```typescript
/**
 * Static Catalog Loader - v3.6
 * Loads pre-built JSON instead of API calls
 */

export interface Product {
  name: string;
  brand: string;
  category: string;
  image_url?: string;
  brand_product_url?: string;
  verified: boolean;
  verification_confidence?: number;
  match_quality?: 'excellent' | 'good';
  halilit_sku?: string;
  halilit_price?: number;
  has_manual?: boolean;
  manual_path?: string;
}

export interface BrandCatalog {
  brand_id: string;
  brand_name: string;
  stats: {
    total_products: number;
    verified_products: number;
    verification_rate: number;
  };
  products: Product[];
}

export interface MasterIndex {
  build_timestamp: string;
  version: string;
  total_products: number;
  total_verified: number;
  brands: Array<{
    id: string;
    name: string;
    product_count: number;
    verified_count: number;
    data_file: string;
  }>;
}

class CatalogLoader {
  private index: MasterIndex | null = null;
  private brandCatalogs: Map<string, BrandCatalog> = new Map();
  private allProducts: Product[] = [];
  
  /**
   * Load master index (call once on app init)
   */
  async loadIndex(): Promise<MasterIndex> {
    if (this.index) return this.index;
    
    const response = await fetch('/data/index.json');
    if (!response.ok) {
      throw new Error('Failed to load catalog index');
    }
    
    this.index = await response.json();
    return this.index;
  }
  
  /**
   * Load specific brand catalog (lazy loading)
   */
  async loadBrand(brandId: string): Promise<BrandCatalog> {
    // Check cache first
    if (this.brandCatalogs.has(brandId)) {
      return this.brandCatalogs.get(brandId)!;
    }
    
    const response = await fetch(`/data/${brandId}.json`);
    if (!response.ok) {
      throw new Error(`Failed to load brand: ${brandId}`);
    }
    
    const catalog = await response.json();
    this.brandCatalogs.set(brandId, catalog);
    
    return catalog;
  }
  
  /**
   * Load all products (for full-text search)
   * Only call this once, then use Fuse.js
   */
  async loadAllProducts(): Promise<Product[]> {
    if (this.allProducts.length > 0) {
      return this.allProducts;
    }
    
    // Load index first to get brand list
    const index = await this.loadIndex();
    
    // Load all brand catalogs in parallel
    const brandPromises = index.brands.map(brand => 
      this.loadBrand(brand.id)
    );
    
    const catalogs = await Promise.all(brandPromises);
    
    // Flatten all products
    this.allProducts = catalogs.flatMap(catalog => 
      catalog.products.map(product => ({
        ...product,
        // Add brand info for filtering
        _brandId: catalog.brand_id,
        _brandName: catalog.brand_name
      }))
    );
    
    return this.allProducts;
  }
  
  /**
   * Get brands list (fast, from index only)
   */
  async getBrands() {
    const index = await this.loadIndex();
    return index.brands;
  }
  
  /**
   * Get statistics
   */
  async getStats() {
    const index = await this.loadIndex();
    return {
      totalProducts: index.total_products,
      totalVerified: index.total_verified,
      totalBrands: index.brands.length,
      verificationRate: (index.total_verified / index.total_products * 100).toFixed(2)
    };
  }
}

// Singleton instance
export const catalogLoader = new CatalogLoader();
```

---

### Phase 2: Add Client-Side Search (Week 2, Day 1-2)

**Install Fuse.js:**
```bash
cd frontend
pnpm add fuse.js
```

**Create: `frontend/src/lib/instantSearch.ts`**

```typescript
import Fuse from 'fuse.js';
import { catalogLoader, type Product } from './catalogLoader';

class InstantSearch {
  private fuse: Fuse<Product> | null = null;
  private products: Product[] = [];
  
  /**
   * Initialize search engine (call once on app load)
   */
  async initialize() {
    // Load all products
    this.products = await catalogLoader.loadAllProducts();
    
    // Configure Fuse.js for fuzzy search
    this.fuse = new Fuse(this.products, {
      keys: [
        { name: 'name', weight: 2.0 },           // Product name most important
        { name: 'brand', weight: 1.5 },          // Brand second
        { name: 'category', weight: 1.0 },       // Category third
        { name: '_brandName', weight: 1.5 }      // Brand name searchable
      ],
      threshold: 0.3,                            // 70% match required
      includeScore: true,
      useExtendedSearch: true,
      minMatchCharLength: 2
    });
    
    console.log(`üîç Search initialized with ${this.products.length} products`);
  }
  
  /**
   * Search products (instant, <50ms)
   */
  search(query: string, options?: {
    brand?: string;
    category?: string;
    verifiedOnly?: boolean;
    limit?: number;
  }): Product[] {
    if (!this.fuse) {
      console.warn('Search not initialized yet');
      return [];
    }
    
    if (!query || query.length < 2) {
      return this.products.slice(0, options?.limit || 50);
    }
    
    // Perform fuzzy search
    let results = this.fuse.search(query, { 
      limit: options?.limit || 100 
    }).map(result => result.item);
    
    // Apply filters
    if (options?.brand) {
      results = results.filter(p => p._brandId === options.brand);
    }
    
    if (options?.category) {
      results = results.filter(p => 
        p.category?.toLowerCase() === options.category?.toLowerCase()
      );
    }
    
    if (options?.verifiedOnly) {
      results = results.filter(p => p.verified);
    }
    
    return results;
  }
  
  /**
   * Get products by brand (fast filter)
   */
  getByBrand(brandId: string): Product[] {
    return this.products.filter(p => p._brandId === brandId);
  }
  
  /**
   * Get products by category (fast filter)
   */
  getByCategory(category: string): Product[] {
    return this.products.filter(p => 
      p.category?.toLowerCase() === category.toLowerCase()
    );
  }
  
  /**
   * Get all unique categories
   */
  getCategories(): string[] {
    const categories = new Set(
      this.products
        .map(p => p.category)
        .filter(Boolean)
    );
    return Array.from(categories).sort();
  }
}

// Singleton instance
export const instantSearch = new InstantSearch();
```

---

### Phase 3: Update App.tsx (Week 2, Day 2)

**Replace the current API call:**

```typescript
// ‚ùå OLD (v3.5) - Remove this
useEffect(() => {
    fetch(`/api/products?v=${Date.now()}`, { cache: 'no-store' })
      .then(res => res.json())
      .then(data => {
          if (data.products) setFullCatalog(data.products);
      })
      .catch(console.error);
}, []);

// ‚úÖ NEW (v3.6) - Add this
import { instantSearch } from './lib/instantSearch';
import { catalogLoader } from './lib/catalogLoader';

useEffect(() => {
  // Initialize static catalog and search
  const initCatalog = async () => {
    try {
      await instantSearch.initialize();
      const products = await catalogLoader.loadAllProducts();
      setFullCatalog(products);
      setBackendAvailable(true);
    } catch (error) {
      console.error('Failed to load catalog:', error);
      setBackendAvailable(false);
    }
  };
  
  initCatalog();
}, []);
```

---

### Phase 4: Update WebSocket Store (Week 2, Day 3)

**Modify: `frontend/src/store/useWebSocketStore.ts`**

```typescript
// Replace WebSocket predictions with instant search

import { instantSearch } from '../lib/instantSearch';

// ‚ùå Remove WebSocket connection logic
// ‚úÖ Add instant search

export const useSearchStore = create((set, get) => ({
  searchQuery: '',
  searchResults: [],
  isSearching: false,
  
  search: async (query: string) => {
    set({ isSearching: true, searchQuery: query });
    
    // Instant search (no API call needed!)
    const results = instantSearch.search(query, {
      limit: 100,
      verifiedOnly: false
    });
    
    set({ 
      searchResults: results,
      isSearching: false 
    });
  },
  
  filterByBrand: (brandId: string) => {
    const results = instantSearch.getByBrand(brandId);
    set({ searchResults: results });
  }
}));
```

---

### Phase 5: Remove API Dependencies (Week 2, Day 4)

**Files to update:**

1. **`ProductCoverageStats.tsx`** - Load from `catalogLoader.getStats()`
2. **`SyncMonitor.tsx`** - Remove (no longer needed in static mode)
3. **`SystemHealthBadge.tsx`** - Remove (no backend to monitor)
4. **`FolderView.tsx`** - Use local image URLs or pre-optimized images

---

## üìä Migration Checklist

### Week 2, Day 1-2: Core Integration
- [ ] Create `lib/catalogLoader.ts`
- [ ] Create `lib/instantSearch.ts`
- [ ] Install Fuse.js (`pnpm add fuse.js`)
- [ ] Test loading index.json
- [ ] Test search performance (<50ms target)

### Week 2, Day 3-4: Component Updates
- [ ] Update `App.tsx` to use static catalog
- [ ] Replace WebSocket with instant search
- [ ] Update `ProductCoverageStats.tsx`
- [ ] Remove `SyncMonitor.tsx` (optional in static mode)
- [ ] Remove `SystemHealthBadge.tsx` (optional)

### Week 2, Day 5: Testing & Optimization
- [ ] Test search performance (should be <50ms)
- [ ] Test brand filtering
- [ ] Test category filtering
- [ ] Verify verified products display correctly
- [ ] Check image loading

---

## üé® Example: Updated Component

**Before (v3.5):**
```tsx
// App.tsx - Old API approach
const [products, setProducts] = useState([]);

useEffect(() => {
  fetch('/api/products')
    .then(res => res.json())
    .then(data => setProducts(data.products));
}, []);

// Search via WebSocket
webSocket.send({ query: userInput });
```

**After (v3.6):**
```tsx
// App.tsx - New static approach
import { instantSearch, catalogLoader } from './lib';

const [products, setProducts] = useState([]);

useEffect(() => {
  // Load once on mount
  catalogLoader.loadAllProducts()
    .then(setProducts);
    
  // Initialize search
  instantSearch.initialize();
}, []);

// Search instantly (no network call)
const handleSearch = (query: string) => {
  const results = instantSearch.search(query);
  setProducts(results);
};
```

---

## ‚ö° Performance Comparison

| Operation | v3.5 (API) | v3.6 (Static) |
|-----------|------------|---------------|
| Initial Load | 3-5s (API + DB) | <2s (static JSON) |
| Search | 200-500ms (WebSocket) | <50ms (Fuse.js) |
| Filter by Brand | 100-200ms (API) | <10ms (array filter) |
| Page Navigation | 50-100ms (API) | <1ms (local state) |

---

## üîß Development Workflow

### 1. Build Static Catalog
```bash
cd backend
python build.py --brand=all
```

### 2. Start Frontend Dev Server
```bash
cd frontend
pnpm dev
# Frontend loads from /data/*.json
```

### 3. Rebuild When Data Changes
```bash
# If backend data updated:
cd backend && python build.py --brand=all

# Frontend auto-reloads new JSON files
```

---

## üåê Production Deployment

### Option 1: Netlify/Vercel (Recommended)
```bash
# Build static site
cd frontend
pnpm build

# Deploy (includes /data/*.json in dist/)
netlify deploy --dir=dist --prod
```

### Option 2: Any Static Host
```bash
# Build creates: dist/data/*.json
# Upload dist/ folder to any CDN/static host
```

**Cost:** $0/month (free tier sufficient)

---

## üéØ Feature Parity

Everything from v3.5 still works, but faster:

| Feature | v3.5 Implementation | v3.6 Implementation |
|---------|---------------------|---------------------|
| Full-text search | WebSocket API | Fuse.js in-memory |
| Brand filtering | API query | Array filter |
| Category filtering | API query | Array filter |
| Verified badge | From API response | From static JSON |
| Product details | API call | From loaded catalog |
| Image optimization | Backend endpoint | Pre-optimized or lazy |

---

## üöÄ Advanced Features (Week 3+)

### 1. Progressive Loading
Load only what's needed:
```typescript
// Load index first (small)
await catalogLoader.loadIndex();

// Load specific brands on-demand
const nordProducts = await catalogLoader.loadBrand('nord');
```

### 2. Service Worker Caching
Cache JSON files for offline:
```typescript
// vite.config.ts
import { VitePWA } from 'vite-plugin-pwa';

export default {
  plugins: [
    VitePWA({
      manifest: { name: 'HSC JIT' },
      workbox: {
        globPatterns: ['**/*.{json,js,css,html}'],
        runtimeCaching: [{
          urlPattern: /^\/data\/.*/,
          handler: 'CacheFirst',
          options: { cacheName: 'catalog-cache' }
        }]
      }
    })
  ]
};
```

### 3. Brand Theming (Chameleon UI)
Use brand colors from static data:
```typescript
const brandTheme = {
  nord: { primary: '#e94b3c', secondary: '#000' },
  roland: { primary: '#d62a26', secondary: '#000' },
  // ... from brand JSON files
};

// Apply dynamically
document.documentElement.style.setProperty(
  '--brand-primary', 
  brandTheme[currentBrand].primary
);
```

---

## üìà Migration Timeline

**Week 2 (Current):**
- Days 1-2: Create loaders & search
- Days 3-4: Update components
- Day 5: Testing & validation

**Week 3:**
- Progressive loading optimization
- Brand theming implementation
- Remove all API dependencies

**Week 4:**
- Production deployment
- Performance monitoring
- User testing

---

## ‚úÖ Success Criteria

You'll know the integration is complete when:

1. ‚úÖ No API calls to backend (check Network tab)
2. ‚úÖ Search results appear in <50ms
3. ‚úÖ All 2,026 products searchable
4. ‚úÖ Brand filtering instant (<10ms)
5. ‚úÖ Page loads in <2 seconds
6. ‚úÖ Build size <5MB (including all JSON)

---

## üÜò Troubleshooting

### "Cannot find module 'fuse.js'"
```bash
cd frontend
pnpm add fuse.js
```

### "Failed to load catalog index"
```bash
# Ensure build ran successfully
cd backend
python build.py --brand=all

# Check output exists
ls -la ../frontend/public/data/
```

### Search is slow (>100ms)
```typescript
// Limit results
instantSearch.search(query, { limit: 50 });

// Or use debouncing
const debouncedSearch = debounce(instantSearch.search, 200);
```

### Images not loading
```typescript
// Use full URLs from JSON
<img src={product.image_url} />

// Or proxy through backend (if still running)
<img src={`/api/images/proxy?url=${encodeURIComponent(product.image_url)}`} />
```

---

## üìö Related Documentation

- [V3.6_GETTING_STARTED.md](V3.6_GETTING_STARTED.md) - Build system quickstart
- [V3.6_STATIC_BUILD_SYSTEM.md](V3.6_STATIC_BUILD_SYSTEM.md) - Technical details
- [V3.6_EXECUTION_SUMMARY.md](V3.6_EXECUTION_SUMMARY.md) - What was built

---

## üéâ Benefits After Integration

1. **‚ö° Performance**: <50ms search vs 200-500ms API calls
2. **üí∞ Cost**: $0/month vs $45/month infrastructure
3. **üöÄ Deployment**: Static files vs Docker orchestration
4. **üì± Offline**: Works offline with service worker
5. **üîí Security**: No backend attack surface
6. **üìà Scalability**: CDN handles any traffic

---

**Ready to integrate?** Start with creating `lib/catalogLoader.ts` and test loading the index! üöÄ
